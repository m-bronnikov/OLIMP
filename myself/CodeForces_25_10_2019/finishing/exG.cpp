// Made by Bronnikov Max
#include <iostream>

using namespace std;


/* 
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////                     ТЕОРИЯ ПО РЕШЕНИЮ ЗАДАЧИ:               ///////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// 1) Сумма членов арифметической прогрессии вычисляется как Sn = b1*(q1^n - 1)/(q - 1)                          //
//                                                                                                               //
// 2) Произведение и сумма по модулю равно произведению остатков по модулю                                       //
//                                                                                                               //
// 3) Остаток называется обратимым, если существует остаток х такой, что произведение остатков по модулю даст 1. //
//    Если остаток обратим => существует единственный корень уравнения ax = b (mod N) => можно взять по модулю N //
//    результат деления чисел, зная остатки делимого и делителя. Для этого необходимо решить ax + Ny = b         //
//                                                                                                               //
// 4) В случае когда N простое все остатки кроме 0 обратимы, причем НОД(a, N) = 1 => решения уравнения целые     //
//                                                                                                               //
// 5) Решить Дефантово уравнение с целыми корнями можно при помощи расширенного алгоритма Евклида                //
//                                                                                                               //
// 6) Взять быстро степень по модулю можно при помощи алгоритма бинарного возведения в степень на основании п.2  //
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////                            РЕШЕНИЕ:                        ///////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// 1) Считываем числа q b1 n в цикле                                                                             //
//                                                                                                               //
// 2) Проверяем на особые значения q                                                                             //
//                                                                                                               //
// 3) Находим q возведенное в степень n по модулю 10^9 + 7(mod) значение q_n(q_n > 0, так как mod простое, q!=0) //
//                                                                                                               //
// 4) Находим решение уравнения (q-1)*t - mod*y = 1 (q-1=(q-1)%mod, так mod > q, а НОД = 1, так как mod простое) //
//                                                                                                               //
// 5) Получаем значение деления q_n - 1 на q - 1 по модулю домножив q_n - 1 на полученное t                      //
//                                                                                                               //
// 6) Вычисляем значения суммы членов прогресси по модулю согласно формуле и выводим значение на экран           // 
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////// Источник: http://www.mi-ras.ru/~podolskii/files/integer.pdf ///////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
 */

long long ext_gcd(long long a, long long b, long long& x, long long& y){
    if(!a){
        x = 0;
        y = 1;
        return b;
    }
    long long x1, y1;
    long long g = ext_gcd(b%a, a, x1, y1);
    x = y1 - (b / a) * x1;
    y = x1;
    return g;
}

long long binpow_mod(long long a, long long n, long long mod){
    long long res = 1;
    while(n){
        if(n & 1){
            res*=a;
            res %= mod; 
        }
        a *= a;
        a %= mod;
        n >>= 1;
    }
    return res;
}


int main(){
    unsigned T;
    const long long mod = 1000000007;
    long long b1, q, n;
    cin >> T;
    for(unsigned i = 0; i < T; ++i){
        cin >> b1 >> q >> n;
        if(!q){
            cout << b1 << endl;
            continue;
        }else if(q == 1){
            cout << (b1 * n) % mod << endl;
            continue;
        }
        long long q_n = binpow_mod(q, n, mod);
        --q_n;
        --q;
        long long t, y;
        ext_gcd(q, mod, t, y);
        if(t < 0){
            t+=mod;
        }
        t *= q_n;
        t %= mod;
        t *= b1;
        t %= mod;
        cout << t << endl;
    } 
    return 0;

}